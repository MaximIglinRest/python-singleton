# Singleton Design Pattern in Python

## Описание паттерна Singleton

**Singleton (Одиночка)** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

---

## Когда использовать Singleton:

1. **Работа с конфигурациями приложения**:
   В больших приложениях необходимо обращаться к конфигурационным файлам для получения настроек. Использование Singleton гарантирует, что конфигурация будет загружена только один раз и будет доступна из любого места программы.

2. **Логирование (Logging)**:
   Логирование — важная часть любой системы. Все компоненты системы должны использовать один и тот же логгер, чтобы избежать создания дубликатов файлов логов или вывода в разные источники.

3. **Подключение к базе данных**:
   В системах, которые работают с базами данных, важно, чтобы приложение имело только одно подключение к базе для управления ресурсами и предотвращения конфликтов.

---

## Реализация Singleton на Python

### 1. Реализация через метакласс

В этой реализации мы используем метакласс для контроля создания экземпляров класса. Если экземпляр уже существует, возвращается сохранённый объект; если нет — создаётся новый.

```python
class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)

        return cls._instances[cls]


class Application(metaclass=Singleton):
    def get_app_id(self) -> None:
        print(id(self))


if __name__ == "__main__":
    app = Application()
    app_2 = Application()

    app.get_app_id()   # Выводит ID экземпляра
    app_2.get_app_id()  # Выводит тот же ID, что и app

```
### 2. Реализация через метод __new__
В этой реализации мы контролируем создание экземпляра через переопределение метода __new__.
```python
class Application:
    __instance = None

    def __new__(cls, *args, **kwargs):
        if not cls.__instance:
            cls.__instance = super().__new__(cls)
        return cls.__instance

    def get_app_id(self) -> None:
        print(id(self))


if __name__ == "__main__":
    app = Application()
    app_2 = Application()

    app.get_app_id()   # Выводит ID экземпляра
    app_2.get_app_id()  # Выводит тот же ID, что и app

```

### Когда использовать какую реализацию?
- Через **метакласс**: Используйте этот вариант, если вы хотите реализовать Singleton для нескольких классов или если вам нужна большая гибкость в управлении созданием экземпляров.
- Через **__new__**: Этот вариант хорошо подходит для простых сценариев, когда требуется Singleton для одного конкретного класса.